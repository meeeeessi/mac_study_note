## 字节

### 1.提问

#### [1.1操作系统中线程、进程联系和区别，上下文切换时发生了什么？](https://blog.csdn.net/u014454538/article/details/99330919)

进程（`Process`）是**资源分配**的基本单位，线程（`Thread`）是**CPU调度**的基本单位。

**线程将进程的资源分配和CPU调度分离开来。** 以前进程既是资源分配又是CPU调度的基本单位，后来为了更好的利用高性能的CPU，将资源分配和CPU调度分开。因此，出现了线程。

**进程和线程的联系：** 一个线程只能属于一个进程，一个进程可以拥有多个线程。线程之间共享进程资源。

**进程和线程的实例：** 打开一个QQ，向朋友A发文字消息是一个线程，向朋友B发语音是一个线程，查看QQ空间是一个线程。QQ软件的运行是一个进程，软件中支持不同的操作，需要由线程去完成这些不同的任务。

#### [1.2Java中final、finally和finalize的区别](https://blog.csdn.net/cyl101816/article/details/67640843)

#### 1.3finally什么情况下不会执行

在try语句块在加上System.exit(1)这句话意指终止当前虚拟机

#### 1.4StackOverflow出现的场景？

#### [1.5从浏览器输入一个URL到返回响应的完整过程](https://blog.csdn.net/qq_41709082/article/details/94474821)

(1).浏览器输入URL 跳转 之后 浏览器 会先判断 这个 链接(URL)是否 需要 重定向（Redirect），需要就会跳转到 重定向页面,不需要的话就进入下一步。
(2).判断是否需要重定向之后 浏览器会判断 这个 访问的 链接 是否 有缓存(之前访问过)。有缓存 直接 从 缓存 取数据，没有缓存则 进入下一步。
(3).做完前面 两步 之后 这个时候 浏览器 就会 开始 真正的 发送请求，发送请求 第一步 就是 域名解析，由于我们 输入 的URL 只是域名，所以浏览器还需要 利用 DNS 解析 域名，解析完成之后 得到 服务器IP 地址 再进行访问。
(4).创建链接 这个 时候 需要 与 服务器 进行 3次握手，如果是https 请求的 话，由于需要做安全机制，所以会和http创建的方式不一样。
(5).握手完成之后，开始 发送 真正的 request请求
(6).服务器 接收到 请求 做出相应的 处理 再 返回 一个 响应(数据)response 给 客户端

#### [1.6网络带宽网速计算，10m带宽的实际下载速度](https://zhuanlan.zhihu.com/p/141671153)

#### [1.7tcp与udp的区别概述](https://blog.csdn.net/sifanchao/article/details/82285018?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&dist_request_id=1328689.20012.16166412596111117&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control)

从特点上我们已经知道，TCP 是可靠的但传输速度慢 ，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。
　　若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。

#### 1.8tcp的三次握手与四次挥手的过程及其原因

TCP三次握手过程

主机A通过向主机B 发送一个含有同步序列号标志位的数据段（SYN）给主机B ，向主机B 请求建立连接，通过这个数据段，主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。
主机B 收到主机A的请求后，用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用哪个序列号作为起始数据段来回应我。
主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：“我已收到回复,我现在要开始传输实际数据了”。
这样3次握手就完成了，主机A和主机B 就可以传输数据了。

TCP四次挥手过程

当主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求。
主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭，将ACK置1。
由B 端再提出反方向的关闭请求，将FIN置1。
主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。



##### 为什么要三次握手

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

**具体例子：**“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”



#### 1.9为什么tcp更可靠

[1] 确认和重传机制

建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础
传输过程中，如果Checksum校验失败、丢包或延时，发送端重传
[2] 数据排序

TCP有专门的序列号SN字段，可提供数据re-order
[3] 流量控制

窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量
[4] 拥塞控制

TCP的拥塞控制由4个核心算法组成。

“慢启动”（Slow Start）

“拥塞避免”（Congestion avoidance）

“快速重传 ”（Fast Retransmit）

“快速恢复”（Fast Recovery）

以上就是TCP比UDP传输更可靠的原因。



#### 1.10tcp一定就不会丢包吗

TCP协议不可能100%不丢包，他采用校验的方法来确定是否丢包。他丢包就会重发。

#### [1.11jvm堆和栈的区别](http://blog.sina.com.cn/s/blog_6b9435b90101ff4b.html)

[jvm堆和栈的区别](https://blog.csdn.net/heart_mine/article/details/79495032)





### 2.算法



### 3.常见的五个异常

多线程并发异常：Java.until.ConcurrentModificationException

